---
date: 2021-12-15 16:45 +0800
title: "specpaxos代码库的一些讨论"
---
<!-- more -->

我曾经想过很多次，ddl之后一觉醒来的第一件事我会做什么。我从没想到自己是在写这个。

当然转过来想想是很合理的。毕竟一时半会我的脑子里什么别的都没有。我的心又受了C++和分布式联合带来的重创。我还能做什么呢。

----

趁热打铁，总结一些specpaxos衍生出的这套codebase的瑕疵。各种类型的问题都有。此时此刻我当然是抱着为重写做准备的心态来总结的。希望后续可以切换到一个更理性的状态。

protobuf的性能和其他问题。代码库中纯计算任务（本身也不多）大体上都有着合理的性能开销（并行模型下面再讨论），只有序列化/反序列化慢的离谱。在0/0性能测试中反序列化的时间稳定大于100%的消息处理时间，而且常常达到两到三倍的延迟比。这也导致了对于baseline把反序列化拿到工作线程中去可以使吞吐翻倍这种离谱的现象。另外，使用带有代码生成的方案对于编辑器的代码分析不算友好。通常有代码生成环节的工作流程都是生成一次代码然后一万年不改变（或者永远向后兼容的改变，也是protobuf设计的一个重要目标），然而这并不适用于这个项目的场合。

说到性能，其实无论是protobuf还是内核/libevent执行模型，都有一个共同的性质就是在架构设计初期没有预想到后续工作在延迟方面突飞猛进的进步。在吞吐量预期100K左右时，每个op有10us的 线性 时间配额，也就是说可以流水线化的步骤不需要算在这10us里，那么拿出2-3us去做一些基础设施服务是可以接受的——更不用说很多协议对replica之间通信的要求使得所有本地的延迟都隐藏在巨大的网络延迟之下了。然而当性能逐渐朝着400-500K发展时，每个op只有接近2us的样子，这时候把消息解包出来就花了1us多，后面的工作啥也不用干了。不管今后还要再做什么工作，对延迟/吞吐量的目标永远不会走回头路。可以说，达到这个性能区间以后量变逐渐引起质变了。

对于common和lib两个目录的代码组织问题。理念上来讲，lib应该只有涉及模型架构的定义，核心就是`Transport`和`TransportReceiver`两个界面，以及紧密相关的`Config`等等。除此之外从各个协议实现中抽出的通用代码都应该放在common中，如打印日志和性能分析等等。当然只是移动一下文件而已问题不大。

少量应该采用值语义的对象用了引用语义，主要是`TransportAddress`和`LogEntry`。和设计上留下的限制有一定关系。

说到设计上的小缺陷，还有另外两个。一个是`TransportReceiver`无法分辨数据包的来源。这主要是因为对multicast的支持大概是后期临时糊上去的（虽然从最初的specpaxos就要用到这个功能了）。从设计上`TransportReceiver`的意图是对单一地址的listener，所以接口里面完全没有这个考虑，导致后面大票的协议只能在数据包当中用专门的字段来区分。这也不一定是一件坏事，毕竟很多时候本来也要在multicast包里包含特殊的信息。但是在应对丢包从其他replica恢复的时候，不能直接从包的来源来区分就有点尴尬了。在很多时候在state transfer reply外面专门包一层倒也没什么，但是等到数据包本来就被包了很多层的时候，结合`Message`设计的不足就有点要命了，后面再说。

另一个小不足是`TransportAddress`和`ReplicaAddress`。前者是一个不透明的地址对象，对`TransportReceiver`隐藏细节；但是有的时候又不能完全隐藏，所以通过`ReplicaAddress`来提供序列化等等功能。两者并没有分立的存在。另外`ReplicaAddress`与IP和端口强绑定也是没有必要的。考虑一个纯粹又DPDK程序构成的网络，采用MAC地址+lcore id来标识一个`TransportReceiver`可能是更好的选择，还能提供一个完全省略IP+UDP层的可能性。

关于`Log`的设计，这个比较深厚。`Log`应该作为一个纯数据结构存在，不应该包含任何协议逻辑。我相信最初`Log`是以这个理念设计的，但它选择了和viewstamp强绑定。也许从一开始viewstamp被看作了是一个replication协议必然依赖的概念和组件吧。但是实际上viewstamp的偏序关系很多协议都用不上，现在又加入了一些transactional协议也不一定要view了，还有一些协议只有view number和op number还不够用，导致viewsteamp里面被逐渐塞进去了越来越多的东西。扯得更远一点，有些基于区块链的协议，其`Log`格式已经不是线性序列了。所以，基于对`Log`的结构的任何假设，为它实现协议的逻辑，是不实用的。

更进一步的，`Log`本身的目的应该是作为 一致性 的具现化表现。有些协议并不要求每一个replica都执行上层应用，但要尽量让所有人都以同样的顺序记录所有的op。从这个角度来说，一个`Replica`中反而不一定要有`AppReplica`但是一定要有`Log`。更好的做法也许是把`AppReplica`重新定义为`Log`的子类。在`Log`上只提供充足的数据操作，以及检查多个`Log`是否具有一致性的断言功能，这对于单元测试很重要。

本来准备按照各个功能引入的前后顺序来写，还是先写说起来简单的吧。从整个架构定性以后加入的各个 patch 基本都是欠妥的。上面提到的臃肿的`viewstamp_t`，以及侵入到各处的`shard number`，都违反了 不为自己用不到的功能付出代价 的原则。类似的还有给`Execute`方法加入的两个`void *`参数。先不提看到`void *`就会死的代码洁癖，因为它打破了老代码的override，在同一个地方坑了我两次，我就已经恨死了。

总体上来说，系统中的每个replica都应该又一个公开的replica id，这是必要的。但是跟shard有关的信息尽量不要下沉到各个模型定义里面，作为子类和子类之间约定俗成的细节更好一点。

后来一系列专门为了调整架构的小重构，大体上都是正确的，比如允许client选择使用的IP/interface。
