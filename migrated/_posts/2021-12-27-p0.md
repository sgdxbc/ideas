---
date: 2021-12-27 09:54 +0800
title: "Final thoughts on C++ coroutine"
---
<!-- more -->
搞一个这样的博客最大的好处，就是可以随便乱写，就算明天再写一篇 不好意思我忽然理解了一切前面那篇当我没说过 也不会对今天造成任何心理压力；同时，如果明天发现自己没想错，又可以堂而皇之的把作文链接往到处贴，进可攻退可守（

这是一篇吐槽C++20协程的作文。过去两天我搞懂了市面上不多的有关资料，然后得出了结论，我的需求没法用协程解决。它固然是可取的，是进步的，所以这篇吐槽也仅仅局限于我自己所处的立场。

----

在Oskr项目里的一个需求是多线程调度。相比它的前辈，Oskr的一个目标就是将工作任务的调度逻辑整合到协议的实现当中去，为transport提供更多的信息帮助其实现更高的效率。赶ddl的时候这个需求临时通过一个单独的runner抽象来实现，在代码中出现了很多闭包回调

```C++
// 收到了一个包
runner.RunPrologue([
  &,
  // 复制后续处理需要的资源
] {
  // 可以并行的步骤
  return [
    &,
    // 再复制接下来要用到的
  ] {
    // 必须串行的步骤
    // ...
  };
});
```

整体上，这其实就是一种特化的continuation passing style，由于不是有垃圾收集的语言，所以还需要手动管理相关对象的生命周期。因此，虽然实践证明这套接口的语义够用了，但是趁着重组抽象的机会还是想对其进行简化，而不是简单的把它整合到transport当中了事。

实际上，这种分阶段执行、多次调度、对象生命周期和任务绑定的结构，与无栈协程的概念几乎完全对应。当
