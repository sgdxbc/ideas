<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>ideas » 1638840780</title><link rel="stylesheet" href="/ideas/assets/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Open+Sans&amp;family=Source+Code+Pro&amp;display=swap"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700"><link rel="icon" type="image/png" sizes="32x32" href="/ideas/assets/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/ideas/assets/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/ideas/assets/apple-touch-icon.png"></head><body><nav class="nav"><div class="nav-container"><a href="/ideas"><h2 class="nav-title">ideas</h2></a><ul><li><a href="/ideas/default/page/0">Posts</a></li><li><a href="/ideas/tags"><del>Tags</del></a></li><li><a href="/ideas/about">About</a></li></ul></div></nav><main><div class="post"><div class="post-info"><time datetime="2021-12-07T09:33:00+08:00">Tue, 7 Dec 2021 09:33:00 +0800</time></div><div class="post-title"></div><div class="post-line"></div><!-- more --><html><head></head><body><p>与值语义对应的，有人叫它对象语义，有人叫它引用语义。考虑到我主要关注它的可变性而不是发消息方面的特性，所以这里选择引用语义的称呼。</p>
<hr>
<p>我现在越来越怀疑specpaxos选择用C++实现，会不会只是因为世界上只有这一门C++，对值语义和引用语义的支持都充分至极，哪怕因此造成语义一团混沌也在所不惜。</p>
<p>当然，如我们所知，没有值语义的语言也可以把引用语义当值语义来用。只是偶尔要记得这一切都不是真的。</p>
<p>但如果是没有引用语义的语言，这事就不好办了。</p>
<hr>
<p>前几天看到网上资料里写着，C++中值语义是默认行为，我还觉得深以为然。</p>
<p>其实引用语义也没有 不默认 到哪里去吧？！唯一的区别就是变量声明的时候多出一个<code>&amp;</code>，这真的很不方便吗。</p>
<p>哪怕同样自由的C语言也啰嗦得多吧。</p>
<p>更不用提我在琢磨的Rust了。</p>
<hr>
<p>在Rust里使用引用语义，最大的障碍就是使用引用。</p>
<p>Rust真有你的，硬是把这么一句本来是废话的话给变得富有意义。</p>
<p>Rust里的引用要考虑可变性，要考虑生命周期。引用不能比对象活得久，引用也不能允许多个更新互相打架。</p>
<p>这是好的。这当然是大好事。这断绝了几乎所有的内存错误，怎么不是好事？</p>
<p>但有的时候，人们用C++写程序，真不是因为那时候还没有Rust（当然，由于那时候确实没有Rust，所以你也不好证明这一点），而是因为用Rust写不出来啊。</p>
<p>我承认，如果一个模型当中，对于对象生命周期的掌握，对于对象独占所属的控制，如果超出了Rust语义的表达能力，那么可以自信地认为它是 不直观 的。</p>
<p>事实上这也是我对specpaxos的初期印象的精确描述。</p>
<p>它包含了一个完善且典型的面向对象的架构。自顶而下的整体设计，无论是那种浑然一体的美感，还是后人在加需求的时候痛苦地在模型上面搞破坏的屎山感，都是如此的经典，如此的面向对象。</p>
<p>我确实花了一阵子才理清楚它的生命周期管理。这其实已经在Rust语境下给它判了死刑。从内存管理的角度来讲，它已经太复杂了。没有可维护性了。</p>
<p>但是，从很多角度来看，这个模型却又是很直观的！</p>
<p>事实就是这样。内存管理不是一个程序的全部。当程序本身的复杂度上升的时候，程序员甚至根本就没有心思去管理内存生命周期了。</p>
<p>一般来说这就是脚本语言的场景了。但如果我们又不能放弃性能呢？</p>
<p>那么这时候就是我们要对编译器讲你TMD少管闲事的时候了。</p>
<p>如果采用了直观的内存模型，就要付出 宏观的编程模型的复杂度 的代价，换做是你你怎么选。</p>
<hr>
<p>我不否认一定有聪明人。他们可以设计出超级牛逼的模型，又直观，又具有对Rust友好的内存模型。</p>
<p>也许再给我一阵子我自己也能做这个聪明人。</p>
<p>但这真的让人感到泄气。不谈客观上的性价比，不谈客观上的可行性，适用性。就只是简单的，主观上的令人泄气。</p>
<p>就像我之前写的。Rust无不浪漫，它从来不是我梦中的语言。</p>
<hr>
<p>最后写点具体的。</p>
<p>值语义的一个大问题就是对多态不友好。</p>
<div class="highlight"><pre class="highlight"><code class="language-rust">trait A {}

let some_a: Vec&lt;Box&lt;dyn A&gt;&gt; = vec![];
</code></pre></div>
<p>当一个对象被加入<code>some_a</code>的时候，它的类型就被抹除了，只能强行通过RTTI找回来，这是很不美好的。</p>
<p>在C++中，我们可以通过引用语义弥补这个瑕疵</p>
<div class="highlight"><pre class="highlight"><code class="language-c++">class A {};

class B : public A {};

vector&lt;A *&gt; some_a;
B *a_b = new B;
some_a.push_back(a_b);
// 继续通过a_b来获取对象作为B的身份
</code></pre></div>
<p>而到了Rust里面，我也不用写出来都明白，对象的生命周期已经被转移给列表了，多态列表选择忘掉对象的类型以后，这个对象的类型就被全世界遗忘了。</p>
<p>当然了，内存也安全了。</p>
<p>但我不开心了。</p>
</body></html></div><div class="pagination"><a class="left arrow" href="/ideas/default/1638777960">&#8592;</a><a class="right arrow" href="/ideas/default/1638849060">&#8594;</a><a class="top" href="#">Top</a></div></main><footer><span>Compiled at <time datetime="2024-03-02T13:06:16.863427390+00:00">2024-03-02 13:06:16.863427390 UTC</time>. Made with Rust using a Tale-inspired theme.</span></footer></body></html>